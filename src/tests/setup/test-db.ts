import { PrismaClient } from "@prisma/client";
import { execSync } from "child_process";
import { randomBytes } from "crypto";
import path from "path";
import fs from "fs";

/**
 * Get the test schema path (created by global setup)
 */
function getTestSchemaPath(): string {
  const testSchemaPath = path.join(process.cwd(), "prisma", "schema.test.prisma");
  
  if (!fs.existsSync(testSchemaPath)) {
    throw new Error(
      "Test schema file not found. Make sure global setup has run. " +
      "The schema.test.prisma file should be created by global-setup.ts"
    );
  }
  
  return testSchemaPath;
}

/**
 * Create a SQLite test database for testing
 * Uses file-based SQLite database that gets cleaned up after tests
 */
export const createTestDatabase = async (): Promise<PrismaClient> => {
  // Generate a unique database file path for each test run
  const dbName = `test_${randomBytes(8).toString("hex")}.db`;
  const dbPath = path.join(process.cwd(), "prisma", dbName);
  const databaseURL = `file:${dbPath}`;

  // Store original DATABASE_URL - ensure we have a backup
  const originalDatabaseURL = process.env.DATABASE_URL;
  
  // Only backup if we don't have a backup already AND it's not a test database
  // This prevents overwriting the real database URL backup
  if (!(globalThis as any).__ORIGINAL_DATABASE_URL) {
    const isTestDatabase = originalDatabaseURL?.startsWith("file:") && originalDatabaseURL.includes("test_");
    if (!isTestDatabase && originalDatabaseURL) {
      // This is a real database URL (PostgreSQL, etc.), backup it
      (globalThis as any).__ORIGINAL_DATABASE_URL = originalDatabaseURL;
    }
  }
  
  // Set DATABASE_URL to the test SQLite database
  process.env.DATABASE_URL = databaseURL;

  // Get test schema path (created by global setup)
  const testSchemaPath = getTestSchemaPath();

  try {
    // Push schema to this test's specific database
    // The Prisma client is already generated by global setup, so we just push the schema
    execSync(`npx prisma db push --schema=${testSchemaPath} --skip-generate --accept-data-loss`, {
      stdio: "pipe",
      env: {
        ...process.env,
        DATABASE_URL: databaseURL,
      },
    });

    // Clear require cache for Prisma client modules
    Object.keys(require.cache).forEach(key => {
      if (key.includes("@prisma/client") || key.includes(".prisma/client")) {
        delete require.cache[key];
      }
    });

    // Import the freshly generated Prisma client
    // Delete the module from cache first to force re-import
    try {
      const clientPath = require.resolve("@prisma/client");
      delete require.cache[clientPath];
    } catch {
      // Ignore if module not found
    }

    // Dynamic import after clearing cache - this should get the SQLite client
    const prismaClientModule = await import("@prisma/client");
    const TestPrismaClient = prismaClientModule.PrismaClient;

    const prisma = new TestPrismaClient({
      datasources: {
        db: {
          url: databaseURL,
        },
      },
      log: process.env.DEBUG ? ["query", "error", "warn"] : ["error"],
    }) as PrismaClient;

    // Store cleanup function
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (prisma as any).__cleanup = async () => {
      await prisma.$disconnect();
      // Clean up database file
      if (fs.existsSync(dbPath)) {
        try {
          fs.unlinkSync(dbPath);
        } catch {
          // Ignore cleanup errors
        }
      }
      // Don't clean up test schema file - it's shared and cleaned up by global teardown
      // Restore original DATABASE_URL from backup if available
      const backupURL = (globalThis as any).__ORIGINAL_DATABASE_URL;
      if (backupURL) {
        process.env.DATABASE_URL = backupURL;
        delete (globalThis as any).__ORIGINAL_DATABASE_URL;
      } else {
        // Fallback: restore original if it wasn't a test database
        const wasTestDatabase = originalDatabaseURL?.startsWith("file:") && originalDatabaseURL.includes("test_");
        if (originalDatabaseURL && !wasTestDatabase) {
          process.env.DATABASE_URL = originalDatabaseURL;
        }
      }
    };

    return prisma;
  } catch (error) {
    // Cleanup on error
    if (fs.existsSync(dbPath)) {
      try {
        fs.unlinkSync(dbPath);
      } catch {
        // Ignore
      }
    }
    // Don't clean up test schema file - it's shared and cleaned up by global teardown
    // Restore original DATABASE_URL from backup if available
    const backupURL = (globalThis as any).__ORIGINAL_DATABASE_URL;
    if (backupURL) {
      process.env.DATABASE_URL = backupURL;
      delete (globalThis as any).__ORIGINAL_DATABASE_URL;
    } else {
      // Fallback: restore original if it wasn't a test database
      const wasTestDatabase = originalDatabaseURL?.startsWith("file:") && originalDatabaseURL.includes("test_");
      if (originalDatabaseURL && !wasTestDatabase) {
        process.env.DATABASE_URL = originalDatabaseURL;
      }
    }
    throw error;
  }
};

export const cleanupTestDatabase = async (prisma: PrismaClient | undefined | null): Promise<void> => {
  if (!prisma) {
    return;
  }
  
  try {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if ((prisma as any).__cleanup) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      await (prisma as any).__cleanup();
    } else {
      await prisma.$disconnect();
    }
  } catch (error) {
    // Ignore cleanup errors
    console.warn("Error during test database cleanup:", error);
  }
};